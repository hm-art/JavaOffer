package o60_ShaiZi;
//方法一：分析可知是递归
// n个骰子排列组合有6^n种可能
// 第一轮，可以把n个骰子分成两堆，一堆只有1个，一堆有n-1个，我们此轮需要计算的就是1-6每个点数与剩下n-1个筛子的点数和
//接下来进行第二轮，将n-1个骰子分成1个和n-2个，将这次这1个骰子的结果累加到第一轮计算的结果上
//再往下进行递归，直至骰子数为0
//一个筛子的和是1-6，两个筛子的和是2-12，依此类推n个骰子点数和是n-6n
//所以可以用一个6n-n+1大小的数组来存在每个可能的点数和出现的频率
//在这个数组中，下标存放的是所得和的点数，值存的是该和出现的次数
//例如 6n-n的位置存放的是和为6n出现的次数，用这个除以总的可能也就是6^n，就是该和出现的概率
//将和为sum的点数保存再数字第sum-n(骰子个数)个元素里
//例如 两个骰子，和为2的点数保存在数组第2-2也就是第0个元素中
//              和为3的点数保存在数组第3-2也就是第1个元素中
public class digui {
    public static void main(String[] args) {
        digui d=new digui();
        d.printP(1);
        d.printP(2);
        d.printP(3);
    }
    //调用核心方法，打印所得的结果
    //n:筛子的总个数
    public void printP(int n){
        if(n<1)
            return;
        //一个筛子的和是1-6，两个筛子的和是2-12，依此类推n个骰子点数和是n-6n
        //所以可以用一个6n-n+1大小的数组来存在每个可能的点数和出现的频率
        int p[]=new int[6*n-n+1];
        getP(n,n,0,p);
        // total：n个骰子排列组合有6^n种可能
        int total=(int)Math.pow(6,n);
        for(int i=n;i<=6*n;i++){
            System.out.println(n+"个骰子，和是"+i+"的概率为"+p[i-n]+"/"+total);
        }
    }
    //递归的核心，得到每种和出现的频率
    //allnum:骰子的总个数
    //cur:当前剩余骰子的个数
    //sum:当前的和的值
    //p[]:在这个数组中，下标存放的是所得和的点数，值存的是该和出现的次数
    public void getP(int allnum,int cur,int sum,int []p){
        if(cur==0){
            //将和为sum的点数保存再数字第sum-n(骰子个数)个元素里
            //例如 两个骰子，和为2的点数保存在数组第2-2也就是第0个元素中
            //     和为3的点数保存在数组第3-2也就是第1个元素中
            p[sum-allnum]++;
            return;
        }
        for(int i=1;i<=6;i++){//骰子一共六个面，所以每个骰子都循环六次
            getP(allnum, cur-1, sum+i, p);
        }
    }
}
